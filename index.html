<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Queen Puzzle</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 10px;
      text-align: center;
    }
    #controls {
      margin-bottom: 10px;
    }
    #board {
      display: grid;
      gap: 2px;
      max-width: 95vw;
      margin: 10px auto;
    }
    .cell {
  width: calc(100vw / 8);         /* æ¯æ ¼å®½åº¦ = å±å¹•å®½åº¦é™¤ä»¥ 8ï¼Œä¿è¯é€‚é… */
  height: calc(100vw / 8);        /* æ­£æ–¹å½¢æ ¼å­ */
  font-size: 6vw;                 /* å­—ä½“æ›´å¤§ä¸€ç‚¹ */
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #aaa;
  user-select: none;
  cursor: pointer;
  transition: background 0.2s;
}
    .cell[data-state="queen"] { background: gold; }
    .cell[data-state="x"] { background: #ccc; }
    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      place-items: center;
      font-size: 2em;
      opacity: 0.3;
      z-index: 5;
    }
    #status {
      font-size: 1.2em;
      margin-top: 10px;
    }
    button, select {
      margin: 5px;
      padding: 6px 12px;
      font-size: 1em;
    }
    #overlay-board {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      display: grid;
      gap: 2px;
      opacity: 0.3;
      z-index: 1;
    }
    #game-container {
      position: relative;
      display: inline-block;
    }
  </style>
</head>
<body>

  <h2>Queen Puzzle</h2>

  <div id="controls">
    æ£‹ç›˜å¤§å°ï¼š
    <select id="sizeSelect" onchange="loadBoard()">
      <option value="6">6 x 6</option>
      <option value="7">7 x 7</option>
      <option value="8">8 x 8</option>
    </select>
    <button onclick="showSolution()">æ˜¾ç¤ºå‚è€ƒè§£</button>
    <button onclick="loadBoard()">å†æ¥ä¸€æ¬¡</button>
  </div>

  <div id="game-container">
    <div id="board"></div>
    <div id="overlay-board"></div>
  </div>

  <div id="status"></div>

  <script>
    const colors = ['#fdd','#dfd','#ddf','#ffd','#dff','#fdf','#eef','#fde','#cfc','#ccf'];
    let data, currentSize = 6;
    let cells = [], overlays = [], regionMap = [], solutionGrid = [];

    function loadJSON() {
  loadBoard(); // åªè°ƒç”¨éšæœºç”Ÿæˆé€»è¾‘
}

    function loadBoard() {
      currentSize = parseInt(document.getElementById("sizeSelect").value);
        const cellSize = Math.floor(90 / currentSize);
  const oldStyle = document.getElementById("dynamic-cell-style");
  if (oldStyle) oldStyle.remove();

  const style = document.createElement("style");
  style.id = "dynamic-cell-style";
  style.innerHTML = `
    .cell {
      width: ${cellSize}vw;
      height: ${cellSize}vw;
      font-size: ${cellSize * 0.6}vw;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #aaa;
      user-select: none;
      cursor: pointer;
    }
  `;
  document.head.appendChild(style);
      
      const board = document.getElementById("board");
      const overlayBoard = document.getElementById("overlay-board");
      board.innerHTML = '';
      overlayBoard.innerHTML = '';
      board.style.gridTemplateColumns = `repeat(${currentSize}, 1fr)`;
      overlayBoard.style.gridTemplateColumns = `repeat(${currentSize}, 1fr)`;
      cells = []; overlays = [];

      let boardData = null;
let attempts = 0;

while (!boardData && attempts < 20) {
  boardData = generateBoard(currentSize);
  attempts++;
}

if (!boardData) {
  alert("ç”Ÿæˆæ£‹ç›˜å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
  return;
}

regionMap = boardData.region_map;
solutionGrid = boardData.solution_grid;

      for (let r = 0; r < currentSize; r++) {
        cells[r] = []; overlays[r] = [];
        for (let c = 0; c < currentSize; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.state = "empty";
          cell.style.background = colors[(regionMap[r][c]-1)%colors.length];
          cell.addEventListener("click", () => toggleCell(cell));
          board.appendChild(cell);
          cells[r][c] = cell;

          const ov = document.createElement("div");
          ov.className = "cell";
          ov.textContent = solutionGrid[r][c] === "queen" ? "ğŸ‘‘" : "âŒ";
          overlayBoard.appendChild(ov);
          overlays[r][c] = ov;
        }
      }
      document.getElementById("status").textContent = '';
      document.getElementById("overlay-board").style.display = "none";
    }

    function toggleCell(cell) {
      const state = cell.dataset.state;
      if (state === "empty") {
        cell.dataset.state = "x";
        cell.textContent = "âŒ";
      } else if (state === "x") {
        cell.dataset.state = "queen";
        cell.textContent = "ğŸ‘‘";
      } else {
        cell.dataset.state = "empty";
        cell.textContent = "";
      }
      checkWin();
    }

    function showSolution() {
      document.getElementById("overlay-board").style.display = "grid";
    }

    function checkWin() {
      let filled = 0, queens = [];
      const rows = Array(currentSize).fill(0);
      const cols = Array(currentSize).fill(0);
      const regionQueens = {};

      for (let r = 0; r < currentSize; r++) {
        for (let c = 0; c < currentSize; c++) {
          const cell = cells[r][c];
          const state = cell.dataset.state;
          if (state !== "empty") filled++;
          if (state === "queen") {
            rows[r]++;
            cols[c]++;
            const reg = regionMap[r][c];
            regionQueens[reg] = (regionQueens[reg] || 0) + 1;
            queens.push([r,c]);
          }
        }
      }

      let conflict = false;
      if (filled < currentSize * currentSize) return;

      if (rows.some(v => v > 1) || cols.some(v => v > 1)) conflict = true;
      if (Object.values(regionQueens).some(v => v > 1)) conflict = true;
      for (let i = 0; i < queens.length; i++) {
        for (let j = i+1; j < queens.length; j++) {
          const [r1,c1] = queens[i], [r2,c2] = queens[j];
          if (Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1) conflict = true;
          if (Math.abs(r1 - r2) === Math.abs(c1 - c2)) conflict = true;
        }
      }

      const status = document.getElementById("status");
      status.textContent = conflict ? "âŒ æœ‰å†²çªæˆ–æœªå®Œæˆ" : "ğŸ‰ æ­å–œå®Œæˆï¼";
      status.style.color = conflict ? "red" : "green";
    }

function generateBoard(size) {
  const queenCount = { 6: 6, 7: 7, 8: 9 }[size];
  const maxRegionSize = Math.floor((size * size) / queenCount);
  const minRegionSize = 3;

  // Step 1: éšæœºç”Ÿæˆè¿é€šåŒºåŸŸåˆ’åˆ†
  function generateRegions() {
    const grid = Array.from({ length: size }, () => Array(size).fill(0));
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    let regionId = 1;
    let remaining = size * size;

    while (regionId <= queenCount) {
      // æ‰¾ä¸€ä¸ªå°šæœªå ç”¨çš„èµ·ç‚¹
      let found = false;
      for (let attempt = 0; attempt < 1000; attempt++) {
        const r = Math.floor(Math.random() * size);
        const c = Math.floor(Math.random() * size);
        if (grid[r][c] === 0) {
          // BFS æ‰©å±•
          const queue = [[r, c]];
          const cells = [[r, c]];
          grid[r][c] = regionId;

          while (queue.length && cells.length < maxRegionSize) {
            const [x, y] = queue.shift();
            for (const [dx, dy] of directions) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < size && ny >= 0 && ny < size && grid[nx][ny] === 0) {
                grid[nx][ny] = regionId;
                queue.push([nx, ny]);
                cells.push([nx, ny]);
                if (cells.length >= minRegionSize && Math.random() < 0.3) break;
              }
            }
          }

          if (cells.length >= minRegionSize) {
            regionId++;
            remaining -= cells.length;
            found = true;
            break;
          } else {
            // å¡«ä¸å¤Ÿï¼Œæ’¤é”€
            for (const [x, y] of cells) grid[x][y] = 0;
          }
        }
      }

      if (!found) return null; // æ— æ³•ç»§ç»­ç”Ÿæˆ
    }

    return grid;
  }

  // Step 2: åœ¨æ¯ä¸ªåŒºåŸŸæ”¾ç½®çš‡åï¼ˆä¸å†²çªï¼‰
  function placeQueens(regionMap) {
    const queenPositions = [];
    const rows = new Set();
    const cols = new Set();
    const queens = [];

    for (let regionId = 1; regionId <= queenCount; regionId++) {
      const candidates = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (regionMap[r][c] === regionId) {
            candidates.push([r, c]);
          }
        }
      }

      // éšæœºå°è¯•è¯¥åŒºåŸŸçš„æ‰€æœ‰å€™é€‰æ ¼å­
      let placed = false;
      shuffleArray(candidates);
      for (const [r, c] of candidates) {
        if (
          !rows.has(r) &&
          !cols.has(c) &&
          queens.every(([qr, qc]) =>
            Math.abs(qr - r) !== Math.abs(qc - c) &&
            Math.abs(qr - r) > 1 || Math.abs(qc - c) > 1
          )
        ) {
          queens.push([r, c]);
          rows.add(r);
          cols.add(c);
          placed = true;
          break;
        }
      }

      if (!placed) return null; // å½“å‰åŒºåŸŸæ”¾ä¸äº†åˆæ³•çš‡å
    }

    return queens;
  }

  // Fisher-Yates æ´—ç‰Œ
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  for (let attempt = 0; attempt < 100; attempt++) {
    const regionMap = generateRegions();
    if (!regionMap) continue;

    const queens = placeQueens(regionMap);
    if (!queens) continue;

    const solutionGrid = Array.from({ length: size }, () => Array(size).fill("x"));
    for (const [r, c] of queens) solutionGrid[r][c] = "queen";
    return { region_map: regionMap, solution_grid: solutionGrid };
  }

  return null;
}

    loadJSON();
  </script>
</body>
</html>
